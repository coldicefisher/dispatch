import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Inject, Optional, PLATFORM_ID, Directive, Input, SkipSelf, NgModule } from '@angular/core';
import { isPlatformServer, DOCUMENT, CommonModule } from '@angular/common';
import { Subscription, BehaviorSubject, animationFrameScheduler, from, EMPTY } from 'rxjs';
import { debounceTime, switchMap, catchError, mergeMap } from 'rxjs/operators';
import { __awaiter } from 'tslib';

const LAZY_ELEMENT_CONFIGS = new InjectionToken('LAZY_ELEMENT_CONFIGS');
const LAZY_ELEMENT_ROOT_OPTIONS = new InjectionToken('LAZY_ELEMENT_ROOT_OPTIONS');
const LAZY_ELEMENT_ROOT_GUARD = new InjectionToken('LAZY_ELEMENT_ROOT_GUARD');
const LAZY_ELEMENTS_REGISTRY = new InjectionToken('LAZY_ELEMENTS_REGISTRY', {
    providedIn: 'root',
    factory: () => new Map(),
});

const LOG_PREFIX$2 = '@angular-extensions/elements';
class LazyElementsLoaderService {
    constructor(errorHandler, registry, options) {
        this.errorHandler = errorHandler;
        this.registry = registry;
        this.options = options;
        this.configs = [];
        if (!options) {
            this.options = {};
        }
    }
    addConfigs(newConfigs) {
        newConfigs.forEach((newConfig) => {
            const existingConfig = this.getElementConfig(newConfig.tag);
            if (existingConfig) {
                ngDevMode &&
                    console.warn(`${LOG_PREFIX$2} - ElementConfig for tag '${newConfig.tag}' was previously added, it will not be added multiple times, continue...`);
            }
            else {
                newConfig.isAdded = true;
                this.configs.push(newConfig);
                const shouldPreload = newConfig.preload !== undefined
                    ? newConfig.preload
                    : this.options.preload;
                if (shouldPreload) {
                    this.loadElement(newConfig.url, newConfig.tag, newConfig.isModule, newConfig.importMap, newConfig.hooks);
                }
            }
        });
    }
    getElementConfig(tag) {
        return this.configs.find((config) => config.tag === tag);
    }
    preload(tags) {
        let configs = this.configs;
        if (tags) {
            configs = this.configs.filter((config) => tags.includes(config.tag));
        }
        configs.forEach((config) => this.loadElement(config.url, config.tag, config.isModule, config.importMap, config.hooks));
    }
    loadElement(url, tag, isModule, importMap, hooksConfig) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        return __awaiter(this, void 0, void 0, function* () {
            const config = this.getElementConfig(tag);
            isModule !== null && isModule !== void 0 ? isModule : (isModule = (_a = config === null || config === void 0 ? void 0 : config.isModule) !== null && _a !== void 0 ? _a : this.options.isModule);
            importMap !== null && importMap !== void 0 ? importMap : (importMap = (_b = config === null || config === void 0 ? void 0 : config.importMap) !== null && _b !== void 0 ? _b : this.options.importMap);
            if (ngDevMode && !tag) {
                throw new Error(`${LOG_PREFIX$2} - tag for '${url}' not found, the *axLazyElement has to be used on HTML element`);
            }
            if (!url) {
                if (ngDevMode && !(config === null || config === void 0 ? void 0 : config.url) && !importMap) {
                    throw new Error(`${LOG_PREFIX$2} - url for <${tag}> not found`);
                }
                else if (importMap) {
                    url = tag;
                }
                else {
                    url = config.url;
                }
            }
            if (!this.hasElement(url)) {
                const notifier = this.addElement(url);
                const beforeLoadHook = (_e = (_c = hooksConfig === null || hooksConfig === void 0 ? void 0 : hooksConfig.beforeLoad) !== null && _c !== void 0 ? _c : (_d = config === null || config === void 0 ? void 0 : config.hooks) === null || _d === void 0 ? void 0 : _d.beforeLoad) !== null && _e !== void 0 ? _e : (_g = (_f = this.options) === null || _f === void 0 ? void 0 : _f.hooks) === null || _g === void 0 ? void 0 : _g.beforeLoad;
                const afterLoadHook = (_k = (_h = hooksConfig === null || hooksConfig === void 0 ? void 0 : hooksConfig.afterLoad) !== null && _h !== void 0 ? _h : (_j = config === null || config === void 0 ? void 0 : config.hooks) === null || _j === void 0 ? void 0 : _j.afterLoad) !== null && _k !== void 0 ? _k : (_m = (_l = this.options) === null || _l === void 0 ? void 0 : _l.hooks) === null || _m === void 0 ? void 0 : _m.afterLoad;
                if (importMap) {
                    url = yield this.resolveImportMap(url);
                }
                const script = document.createElement('script');
                if (isModule) {
                    script.type = 'module';
                }
                script.src = url;
                const onLoad = () => {
                    if (afterLoadHook) {
                        this.handleHook(afterLoadHook, tag)
                            .then(notifier.resolve)
                            .catch(notifier.reject);
                    }
                    else {
                        notifier.resolve();
                    }
                    cleanup();
                };
                const onError = (error) => {
                    notifier.reject(error);
                    cleanup();
                    // Caretaker note: don't put it before the `reject` and `cleanup` since the user may have some
                    // custom error handler that will re-throw the error through `throw error`. Hence the code won't
                    // be executed, and the promise won't be rejected.
                    this.errorHandler.handleError(error);
                };
                // The `load` and `error` event listeners capture `this`. That's why they have to be removed manually.
                // Otherwise, the `LazyElementsLoaderService` is not going to be GC'd.
                function cleanup() {
                    script.removeEventListener('load', onLoad);
                    script.removeEventListener('error', onError);
                }
                script.addEventListener('load', onLoad);
                script.addEventListener('error', onError);
                if (beforeLoadHook) {
                    this.handleHook(beforeLoadHook, tag)
                        .then(() => document.body.appendChild(script))
                        .catch(notifier.reject);
                }
                else {
                    document.body.appendChild(script);
                }
            }
            return this.registry.get(this.stripUrlProtocol(url));
        });
    }
    addElement(url) {
        let notifier;
        this.registry.set(this.stripUrlProtocol(url), new Promise((resolve, reject) => (notifier = { resolve, reject })));
        return notifier;
    }
    hasElement(url) {
        return this.registry.has(this.stripUrlProtocol(url));
    }
    stripUrlProtocol(url) {
        return url.replace(/https?:\/\//, '');
    }
    handleHook(hook, tag) {
        try {
            return Promise.resolve(hook(tag));
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    resolveImportMap(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const System = window.System;
            if (System) {
                yield System.prepareImport();
                url = System.resolve(url);
            }
            else if (ngDevMode) {
                throw new Error(`${LOG_PREFIX$2} - importMap feature depends on SystemJS library to be globally loaded but none was found, thus '${url}' can't be resolved. You should either load SystemJS or remove the importMap flag.`);
            }
            return url;
        });
    }
}
LazyElementsLoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementsLoaderService, deps: [{ token: i0.ErrorHandler }, { token: LAZY_ELEMENTS_REGISTRY }, { token: LAZY_ELEMENT_ROOT_OPTIONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
LazyElementsLoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementsLoaderService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementsLoaderService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i0.ErrorHandler }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LAZY_ELEMENTS_REGISTRY]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [LAZY_ELEMENT_ROOT_OPTIONS]
                }] }]; } });

const LOG_PREFIX$1 = '@angular-extensions/elements';
class LazyElementDirective {
    constructor(platformId, vcr, template, elementsLoaderService, cfr, cdr) {
        this.platformId = platformId;
        this.vcr = vcr;
        this.template = template;
        this.elementsLoaderService = elementsLoaderService;
        this.cfr = cfr;
        this.cdr = cdr;
        this.url = null;
        this.loadingTemplateRef = null;
        this.errorTemplateRef = null;
        this.isModule = false; // eslint-disable-line @angular-eslint/no-input-rename
        this.importMap = false; // eslint-disable-line @angular-eslint/no-input-rename
        this.viewRef = null;
        this.subscription = Subscription.EMPTY;
        this.url$ = new BehaviorSubject(null);
    }
    ngOnChanges(changes) {
        if (changes.url) {
            this.url$.next(this.url);
        }
    }
    ngOnInit() {
        // There's no sense to execute the below logic on the Node.js side since the JavaScript
        // will not be loaded on the server-side (Angular will only append the script to body).
        // The `loadElement` promise will never be resolved, since it gets resolved when the `load` event is emitted.
        // `customElements` are also undefined on the Node.js side; thus, it will always render the error template.
        if (isPlatformServer(this.platformId)) {
            return;
        }
        this.setupUrlListener();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    destroyEmbeddedView() {
        if (this.viewRef && !this.viewRef.destroyed) {
            this.viewRef.detach();
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
    setupUrlListener() {
        const tpl = this.template;
        const elementTag = tpl._declarationTContainer
            ? tpl._declarationTContainer.tagName || tpl._declarationTContainer.value
            : tpl._def.element.template.nodes[0].element.name;
        const elementConfig = this.elementsLoaderService.getElementConfig(elementTag) ||
            {};
        const options = this.elementsLoaderService.options;
        const loadingComponent = elementConfig.loadingComponent || options.loadingComponent;
        this.subscription = this.url$
            .pipe(
        // This is used to coalesce changes since the `url$` subject might emit multiple values initially, e.g.
        // `null` (initial value) and the url itself (when the `url` binding is provided).
        // The `animationFrameScheduler` is used to prevent the frame drop.
        debounceTime(0, animationFrameScheduler), switchMap((url) => {
            if (this.loadingTemplateRef) {
                this.vcr.createEmbeddedView(this.loadingTemplateRef);
            }
            else if (loadingComponent) {
                const factory = this.cfr.resolveComponentFactory(loadingComponent);
                this.vcr.createComponent(factory);
            }
            return from(this.elementsLoaderService.loadElement(url, elementTag, this.isModule, this.importMap, elementConfig === null || elementConfig === void 0 ? void 0 : elementConfig.hooks)).pipe(catchError(() => {
                this.vcr.clear();
                const errorComponent = elementConfig.errorComponent || options.errorComponent;
                if (this.errorTemplateRef) {
                    this.vcr.createEmbeddedView(this.errorTemplateRef);
                    this.cdr.markForCheck();
                }
                else if (errorComponent) {
                    const factory = this.cfr.resolveComponentFactory(errorComponent);
                    this.vcr.createComponent(factory);
                    this.cdr.markForCheck();
                }
                else if (ngDevMode) {
                    console.error(`${LOG_PREFIX$1} - Loading of element <${elementTag}> failed, please provide <ng-template #error>Loading failed...</ng-template> and reference it in *axLazyElement="errorTemplate: error" to display customized error message in place of element`);
                }
                return EMPTY;
            }));
        }), mergeMap(() => customElements.whenDefined(elementTag)))
            .subscribe({
            next: () => {
                this.vcr.clear();
                this.viewRef = this.vcr.createEmbeddedView(this.template);
                this.cdr.markForCheck();
            },
        });
    }
}
LazyElementDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementDirective, deps: [{ token: PLATFORM_ID }, { token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: LazyElementsLoaderService }, { token: i0.ComponentFactoryResolver }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
LazyElementDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.1.0", type: LazyElementDirective, selector: "[axLazyElement]", inputs: { url: ["axLazyElement", "url"], loadingTemplateRef: ["axLazyElementLoadingTemplate", "loadingTemplateRef"], errorTemplateRef: ["axLazyElementErrorTemplate", "errorTemplateRef"], isModule: ["axLazyElementModule", "isModule"], importMap: ["axLazyElementImportMap", "importMap"] }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[axLazyElement]',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: LazyElementsLoaderService }, { type: i0.ComponentFactoryResolver }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { url: [{
                type: Input,
                args: ['axLazyElement']
            }], loadingTemplateRef: [{
                type: Input,
                args: ['axLazyElementLoadingTemplate']
            }], errorTemplateRef: [{
                type: Input,
                args: ['axLazyElementErrorTemplate']
            }], isModule: [{
                type: Input,
                args: ['axLazyElementModule']
            }], importMap: [{
                type: Input,
                args: ['axLazyElementImportMap']
            }] } });

const LOG_PREFIX = '@angular-extensions/elements';
class LazyElementDynamicDirective {
    constructor(platformId, document, renderer, vcr, cfr, cdr, template, elementsLoaderService) {
        this.platformId = platformId;
        this.document = document;
        this.renderer = renderer;
        this.vcr = vcr;
        this.cfr = cfr;
        this.cdr = cdr;
        this.template = template;
        this.elementsLoaderService = elementsLoaderService;
        this.tag = null;
        this.url = null; // eslint-disable-line @angular-eslint/no-input-rename
        this.loadingTemplateRef = null;
        this.errorTemplateRef = null;
        this.isModule = false; // eslint-disable-line @angular-eslint/no-input-rename
        this.importMap = false; // eslint-disable-line @angular-eslint/no-input-rename
        this.viewRef = null;
        this.subscription = Subscription.EMPTY;
    }
    ngOnInit() {
        // There's no sense to execute the below logic on the Node.js side since the JavaScript
        // will not be loaded on the server-side (Angular will only append the script to body).
        // The `loadElement` promise will never be resolved, since it gets resolved when the `load` event is emitted.
        // `customElements` are also undefined on the Node.js side; thus, it will always render the error template.
        if (isPlatformServer(this.platformId)) {
            return;
        }
        if (ngDevMode) {
            if (!this.tag || this.tag.length === 0 || !this.tag.includes('-')) {
                throw new Error(`${LOG_PREFIX} - Valid tag has to be specified when using *axLazyElementDynamic directive (use *axLazyElementDynamic="'some-tag'"), got: "${this.tag}"`);
            }
        }
        const tag = this.tag;
        const elementConfig = this.elementsLoaderService.getElementConfig(tag) || {};
        const options = this.elementsLoaderService.options;
        const loadingComponent = elementConfig.loadingComponent || options.loadingComponent;
        if (this.loadingTemplateRef) {
            this.vcr.createEmbeddedView(this.loadingTemplateRef);
        }
        else if (loadingComponent) {
            const factory = this.cfr.resolveComponentFactory(loadingComponent);
            this.vcr.createComponent(factory);
        }
        const loadElement$ = from(this.elementsLoaderService.loadElement(this.url, tag, this.isModule, this.importMap, elementConfig === null || elementConfig === void 0 ? void 0 : elementConfig.hooks));
        this.subscription = loadElement$
            .pipe(mergeMap(() => customElements.whenDefined(tag)))
            .subscribe({
            next: () => {
                this.vcr.clear();
                const originalCreateElement = this.renderer.createElement;
                this.renderer.createElement = (name, namespace) => {
                    if (name === 'ax-lazy-element') {
                        name = tag;
                    }
                    return this.document.createElement(name);
                };
                this.viewRef = this.vcr.createEmbeddedView(this.template);
                this.renderer.createElement = originalCreateElement;
                this.cdr.markForCheck();
            },
            error: (error) => {
                const errorComponent = elementConfig.errorComponent || options.errorComponent;
                this.vcr.clear();
                if (this.errorTemplateRef) {
                    this.vcr.createEmbeddedView(this.errorTemplateRef);
                    this.cdr.markForCheck();
                }
                else if (errorComponent) {
                    const factory = this.cfr.resolveComponentFactory(errorComponent);
                    this.vcr.createComponent(factory);
                    this.cdr.markForCheck();
                }
                else if (ngDevMode) {
                    console.error(`${LOG_PREFIX} - Loading of element <${this.tag}> failed, please provide <ng-template #error>Loading failed...</ng-template> and reference it in *axLazyElementDynamic="errorTemplate: error" to display customized error message in place of element\n\n`, error);
                }
            },
        });
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    destroyEmbeddedView() {
        if (this.viewRef && !this.viewRef.destroyed) {
            this.viewRef.detach();
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
}
LazyElementDynamicDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementDynamicDirective, deps: [{ token: PLATFORM_ID }, { token: DOCUMENT }, { token: i0.Renderer2 }, { token: i0.ViewContainerRef }, { token: i0.ComponentFactoryResolver }, { token: i0.ChangeDetectorRef }, { token: i0.TemplateRef }, { token: LazyElementsLoaderService }], target: i0.ɵɵFactoryTarget.Directive });
LazyElementDynamicDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.1.0", type: LazyElementDynamicDirective, selector: "[axLazyElementDynamic]", inputs: { tag: ["axLazyElementDynamic", "tag"], url: ["axLazyElementDynamicUrl", "url"], loadingTemplateRef: ["axLazyElementDynamicLoadingTemplate", "loadingTemplateRef"], errorTemplateRef: ["axLazyElementDynamicErrorTemplate", "errorTemplateRef"], isModule: ["axLazyElementDynamicModule", "isModule"], importMap: ["axLazyElementDynamicImportMap", "importMap"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementDynamicDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[axLazyElementDynamic]',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.Renderer2 }, { type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }, { type: i0.ChangeDetectorRef }, { type: i0.TemplateRef }, { type: LazyElementsLoaderService }]; }, propDecorators: { tag: [{
                type: Input,
                args: ['axLazyElementDynamic']
            }], url: [{
                type: Input,
                args: ['axLazyElementDynamicUrl']
            }], loadingTemplateRef: [{
                type: Input,
                args: ['axLazyElementDynamicLoadingTemplate']
            }], errorTemplateRef: [{
                type: Input,
                args: ['axLazyElementDynamicErrorTemplate']
            }], isModule: [{
                type: Input,
                args: ['axLazyElementDynamicModule']
            }], importMap: [{
                type: Input,
                args: ['axLazyElementDynamicImportMap']
            }] } });

"use strict";

function createLazyElementRootGuard(rootOptions) {
    if (ngDevMode && rootOptions) {
        throw new TypeError(`LazyElementsModule.forRoot() called twice. Feature modules should use LazyElementsModule.forFeature() instead.`);
    }
    return 'LazyElementsModule.forRoot() multiple execution guard';
}
class LazyElementsModule {
    constructor(lazyElementsLoaderService, elementConfigsMultiProvider, guard) {
        if (elementConfigsMultiProvider && elementConfigsMultiProvider.length) {
            elementConfigsMultiProvider
                .filter((configs) => configs.some((config) => !config.isAdded))
                .forEach((configs) => lazyElementsLoaderService.addConfigs(configs));
        }
    }
    static forRoot(options) {
        return {
            ngModule: LazyElementsModule,
            providers: [
                {
                    provide: LAZY_ELEMENT_CONFIGS,
                    useValue: options && options.elementConfigs ? options.elementConfigs : [],
                    multi: true,
                },
                {
                    provide: LAZY_ELEMENT_ROOT_OPTIONS,
                    useValue: options.rootOptions ? options.rootOptions : {},
                },
                {
                    provide: LAZY_ELEMENT_ROOT_GUARD,
                    useFactory: createLazyElementRootGuard,
                    deps: [[LAZY_ELEMENT_ROOT_OPTIONS, new Optional(), new SkipSelf()]],
                },
            ],
        };
    }
    static forFeature(options) {
        return {
            ngModule: LazyElementsModule,
            providers: [
                {
                    provide: LAZY_ELEMENT_CONFIGS,
                    useValue: options && options.elementConfigs ? options.elementConfigs : [],
                    multi: true,
                },
            ],
        };
    }
}
LazyElementsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementsModule, deps: [{ token: LazyElementsLoaderService }, { token: LAZY_ELEMENT_CONFIGS, optional: true }, { token: LAZY_ELEMENT_ROOT_GUARD, optional: true }], target: i0.ɵɵFactoryTarget.NgModule });
LazyElementsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementsModule, declarations: [LazyElementDirective, LazyElementDynamicDirective], imports: [CommonModule], exports: [LazyElementDirective, LazyElementDynamicDirective] });
LazyElementsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementsModule, providers: [], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.0", ngImport: i0, type: LazyElementsModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [LazyElementDirective, LazyElementDynamicDirective],
                    imports: [CommonModule],
                    exports: [LazyElementDirective, LazyElementDynamicDirective],
                    providers: [],
                }]
        }], ctorParameters: function () { return [{ type: LazyElementsLoaderService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [LAZY_ELEMENT_CONFIGS]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [LAZY_ELEMENT_ROOT_GUARD]
                }] }]; } });

/*
 * Public API Surface of elements
 */

/**
 * Generated bundle index. Do not edit.
 */

export { LAZY_ELEMENTS_REGISTRY, LAZY_ELEMENT_CONFIGS, LAZY_ELEMENT_ROOT_GUARD, LAZY_ELEMENT_ROOT_OPTIONS, LazyElementDirective, LazyElementDynamicDirective, LazyElementsLoaderService, LazyElementsModule, createLazyElementRootGuard };
//# sourceMappingURL=angular-extensions-elements.js.map
